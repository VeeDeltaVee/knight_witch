use crate::{
    board::{chess_move::ChessMove, piece::Side, Board},
    evaluation::{
        evaluation_result::{Depth, Evaluation},
        Evaluator,
    },
};

use super::Searcher;

pub struct AlphabetaSearch<ME, PE> {
    depth: Depth,
    move_sorting_evaluator: ME,
    final_position_evaluator: PE,
}

impl<ME, PE> AlphabetaSearch<ME, PE>
where
    PE: Evaluator,
    ME: Evaluator,
{
    #[allow(dead_code)]
    pub fn new(mse: ME, fpe: PE) -> Self {
        AlphabetaSearch {
            depth: 4,
            move_sorting_evaluator: mse,
            final_position_evaluator: fpe,
        }
    }

    fn search_order_impl(
        &self,
        board: &Board,
        depth: Depth,
        mut alpha: Evaluation,
        mut beta: Evaluation,
    ) -> Result<Vec<(ChessMove, Evaluation)>, &'static str> {
        let moves = board.generate_moves(true)?;

        if moves.is_empty() {
            return Ok(vec![(
                ChessMove::NullMove,
                self.final_position_evaluator.evaluate(board)?,
            )]);
        }

        // Sort the moves by preference order of the current player
        // Because we have to make the moves on a board to figure out this
        // order, we also cache the boards here
        let moved_boards_iter = moves.into_iter().map(|m| {
            let mut moved_board = board.clone();

            // This can't fail, because it was generated by movegen
            moved_board.make_move(m.clone(), false).unwrap();

            (m, moved_board)
        });

        if depth <= 1 {
            let mut moves_in_order: Vec<_> = moved_boards_iter
                .map(|(m, b)| {
                    (m, self.final_position_evaluator.evaluate(&b).unwrap())
                })
                .collect();
            moves_in_order.sort_unstable_by_key(|(_, e)| *e);
            if board.get_current_side() == Side::Black {
                moves_in_order.reverse();
            }

            return Ok(moves_in_order);
        }

        let mut moved_boards = moved_boards_iter.collect::<Vec<_>>();

        // Note: this sorts in ascending order, meaning the moves best for
        // black are at the start.
        moved_boards.sort_unstable_by_key(|(_, b)| {
            self.move_sorting_evaluator.evaluate(b)
        });
        if board.get_current_side() == Side::White {
            moved_boards.reverse();
        }

        let mut moves_seen_so_far = vec![];
        for (m, b) in moved_boards {
            let search_result =
                self.search_order_impl(&b, depth - 1, alpha, beta)?;

            let current_evaluation =
                if let Some((_, mut opponents_best_evaluation)) =
                    search_result.into_iter().next()
                {
                    opponents_best_evaluation =
                        opponents_best_evaluation.deepen();
                    opponents_best_evaluation
                } else {
                    self.final_position_evaluator.evaluate(&b)?
                };

            moves_seen_so_far.push((m, current_evaluation));

            match board.get_current_side() {
                // If the opponent has a better move elsewhere in
                // the search tree, then they would never chose to go into
                // this variation, so we can just stop searching through
                // this branch for now
                //
                // If not, then we just update the cutoffs, since we've
                // maybe improved our bounds on the best possible moves
                Side::White => {
                    if current_evaluation > beta {
                        break;
                    } else if current_evaluation > alpha {
                        alpha = current_evaluation
                    }
                }
                Side::Black => {
                    if current_evaluation < alpha {
                        break;
                    } else if current_evaluation < beta {
                        beta = current_evaluation
                    }
                }
            }
        }

        // Note: this sorts in ascending order, meaning the moves best for
        // black are at the start.
        moves_seen_so_far.sort_unstable_by_key(|(_, eval)| *eval);
        if board.get_current_side() == Side::White {
            moves_seen_so_far.reverse()
        }

        Ok(moves_seen_so_far)
    }
}

impl<ME, PE> Searcher for AlphabetaSearch<ME, PE>
where
    PE: Evaluator,
    ME: Evaluator,
{
    fn search_order(
        &self,
        board: &Board,
    ) -> Result<Vec<(ChessMove, Evaluation)>, &'static str> {
        self.search_order_impl(
            board,
            self.depth,
            Evaluation::BEST_FOR_BLACK, // worst result for white
            Evaluation::BEST_FOR_WHITE, // worst result for black
        )
    }
}

#[cfg(test)]
mod tests {
    use crate::board::game::ChessResult;
    use crate::evaluation::composite::CompositeEvaluator;
    use crate::evaluation::material::MaterialEvaluator;
    use crate::evaluation::result::ResultEvaluator;

    use super::*;

    #[test]
    fn finds_mate_in_two() {
        let board = Board::from_art(
            ".k......\n\
             ........\n\
             ..K.....\n\
             ..R.....\n\
             ........\n\
             ........\n\
             ........\n\
             ........\n",
        )
        .unwrap();

        let mse = MaterialEvaluator::new();

        let fpe = ResultEvaluator::new();

        let mut searcher = AlphabetaSearch::new(mse, fpe);
        searcher.depth = 4;

        let (_, evaluation) = searcher.search(&board).unwrap();
        assert_eq!(
            evaluation,
            Evaluation::Certain(ChessResult::Checkmate(Side::Black), 3)
        );
    }

    #[test]
    fn finds_mate_in_four() {
        let board = Board::from_art(
            "..N.....\n\
             ........\n\
             k..K....\n\
             ........\n\
             p.PB....\n\
             P.......\n\
             ........\n\
             ........\n",
        )
        .unwrap();

        let mse = MaterialEvaluator::new();

        let re2 = ResultEvaluator::new();
        let me2 = MaterialEvaluator::new();
        let mut fpe = CompositeEvaluator::new();
        fpe.push(Box::new(re2)).push(Box::new(me2));

        let mut searcher = AlphabetaSearch::new(mse, fpe);
        searcher.depth = 8;

        let (_, evaluation) = searcher.search(&board).unwrap();
        assert_eq!(
            evaluation,
            Evaluation::Certain(ChessResult::Checkmate(Side::Black), 7)
        );
    }
}
