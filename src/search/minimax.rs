use crate::evaluation::evaluation_result::Evaluation;
use crate::{
    board::{chess_move::ChessMove, piece::Side, Board},
    evaluation::Evaluator,
};

use super::Searcher;

#[derive(Clone)]
pub struct MinimaxSearch<E> {
    depth: usize,
    evaluator: E,
}

impl<E> MinimaxSearch<E>
where
    E: Evaluator,
{
    #[allow(dead_code)]
    pub fn new(evaluator: E) -> Self {
        MinimaxSearch {
            depth: 4,
            evaluator,
        }
    }

    fn search_order_impl(
        &self,
        board: &Board,
        depth: usize,
    ) -> Result<Vec<(ChessMove, Evaluation)>, &'static str> {
        let moves = board.generate_moves(true)?;

        let mut evaluations = moves
            .iter()
            .map(|m| {
                let mut moved_board = board.clone();

                // We know this move shouldn't fail, since this was
                // generated by the movegen engine
                moved_board.make_move(m.clone(), false).unwrap();

                (m, moved_board)
            })
            .filter_map(|(m, moved_board)| {
                let mut evaluation = None;
                // If depth isn't 0, try to search with depth - 1.
                if depth != 0 {
                    evaluation = self
                        .search_order_impl(&moved_board, depth - 1)
                        .ok()?
                        .into_iter()
                        .next()
                        .map(|(_, eval)| eval.deepen());
                }

                // If we didn't find any evaluation, either because the
                // depth was zero or because the search failed to find any
                // possible moves, just return the current board evaluated
                if evaluation.is_none() {
                    evaluation = self
                        .evaluator
                        .evaluate(&moved_board)
                        .ok()
                        .map(|e| e.deepen());
                }

                evaluation.map(|some_eval| (m.clone(), some_eval))
            })
            .collect::<Vec<_>>();

        evaluations.sort_unstable_by(|(_, eval1), (_, eval2)| eval2.cmp(eval1));

        if board.get_current_side() == Side::Black {
            evaluations.reverse();
        }

        Ok(evaluations)
    }
}

impl<E> Searcher for MinimaxSearch<E>
where
    E: Evaluator,
{
    fn search_order(
        &self,
        board: &Board,
    ) -> Result<Vec<(ChessMove, Evaluation)>, &'static str> {
        self.search_order_impl(board, self.depth)
    }
}

#[cfg(test)]
mod tests {
    use std::convert::TryInto;

    use crate::board::game::ChessResult;
    use crate::evaluation::result::ResultEvaluator;

    use super::*;

    #[test]
    fn finds_simple_mate() {
        let board = Board::from_art(
            "...k....\n\
             ........\n\
             ...K...R\n\
             ........\n\
             ........\n\
             ........\n\
             ........\n\
             ........\n",
        )
        .unwrap();

        let evaluator = ResultEvaluator::new();
        let mut searcher = MinimaxSearch::new(evaluator);
        searcher.depth = 1;

        let (chess_move, evaluation) = searcher.search(&board).unwrap();
        assert_eq!(
            evaluation,
            Evaluation::Certain(ChessResult::Checkmate(Side::Black), 1)
        );

        let expected_move = "h6h8".try_into().unwrap();
        assert_eq!(chess_move, expected_move);
    }

    #[test]
    fn finds_mate_in_two() {
        let board = Board::from_art(
            ".k......\n\
             ........\n\
             ..K.....\n\
             ..R.....\n\
             ........\n\
             ........\n\
             ........\n\
             ........\n",
        )
        .unwrap();

        let evaluator = ResultEvaluator::new();
        let mut searcher = MinimaxSearch::new(evaluator);
        searcher.depth = 3;

        let (_, evaluation) = searcher.search(&board).unwrap();
        assert_eq!(
            evaluation,
            Evaluation::Certain(ChessResult::Checkmate(Side::Black), 3)
        );
    }
}
